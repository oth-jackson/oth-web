"use server";

import { revalidatePath } from "next/cache";
import {
  getAllPosts,
  insertPost,
  updatePostRow,
  deletePostRow,
  formatPostsForDisplay,
  type PostItem,
} from "@/features/cms/data/posts";
import { getDB, tables, type Env, type Post, type NewPost } from "@/db";
import { eq, and, inArray } from "drizzle-orm";
import { getCloudflareContext } from "@opennextjs/cloudflare"; // Import context function
import {
  createPostInputSchema,
  updatePostInputSchema,
} from "@/features/cms/validations"; // Import schemas
import { generateSlug } from "@/features/cms/utils/slug"; // Import the slug utility
import { images, posts } from "@/db/schema"; // Direct import postsTable as well

import { unified } from "unified";
import remarkParse from "remark-parse";
import { visit } from "unist-util-visit";
import type { Root, Image as MdastImage } from "mdast"; // Use a different name for Image type if it conflicts

// Helper function to extract object keys from /api/media/... URLs
function extractObjectKeyFromUrl(
  url: string | null | undefined
): string | null {
  if (!url) return null;
  const prefix = "/api/media/";
  if (url.startsWith(prefix)) {
    return url.substring(prefix.length);
  }
  return null;
}

async function updatePostImageLinks(
  env: Env,
  postId: number,
  featuredImageUrl: string | null | undefined,
  markdownContent: string
) {
  const db = getDB(env);
  let currentObjectKeysInPost: string[] = [];

  // 1. Extract object key from featured image
  const featuredObjectKey = extractObjectKeyFromUrl(featuredImageUrl);
  if (featuredObjectKey) {
    currentObjectKeysInPost.push(featuredObjectKey);
  }

  // 2. Extract object keys from Markdown content using AST parsing
  const processor = unified().use(remarkParse);
  const tree = processor.parse(markdownContent) as Root;

  const markdownImageUrls: string[] = [];
  visit(tree, "image", (node: MdastImage) => {
    // Visit only 'image' (Markdown ![alt](url)) nodes
    if (node.url) {
      markdownImageUrls.push(node.url);
    }
  });

  for (const url of markdownImageUrls) {
    const objectKey = extractObjectKeyFromUrl(url);
    if (objectKey) {
      currentObjectKeysInPost.push(objectKey);
    }
  }

  currentObjectKeysInPost = Array.from(new Set(currentObjectKeysInPost));

  // 3. Get existing image links for this post from postImagesTable
  const existingLinks = await db
    .select({ objectKey: images.objectKey })
    .from(images)
    .where(eq(images.postId, postId));
  const existingObjectKeys = existingLinks.map((link) => link.objectKey);

  const keysToAdd = currentObjectKeysInPost.filter(
    (key) => !existingObjectKeys.includes(key)
  );
  const keysToRemove = existingObjectKeys.filter(
    (key) => !currentObjectKeysInPost.includes(key)
  );

  // D1 (SQLite in Workers) currently does not allow explicit BEGIN TRANSACTION statements generated by Drizzle's transaction API.
  // Execute the mutating queries sequentially instead.

  if (keysToRemove.length > 0) {
    await db
      .delete(images)
      .where(
        and(
          eq(images.postId, postId),
          inArray(images.objectKey, keysToRemove)
        )
      );
    console.log(
      `Removed ${keysToRemove.length} image links for post ${postId}.`
    );
  }

  if (keysToAdd.length > 0) {
    await db
      .insert(images)
      .values(keysToAdd.map((key) => ({ postId, objectKey: key })))
      .onConflictDoNothing();
    console.log(`Added ${keysToAdd.length} image links for post ${postId}.`);
  }

  if (keysToAdd.length === 0 && keysToRemove.length === 0) {
    console.log(`No image link changes for post ${postId}.`);
  }
}

// NOTE: Using getCloudflareContext to access bindings in Server Actions
function getEnv(): Env {
  // This assumes getCloudflareContext works synchronously in server actions
  // or you might need to make the actions themselves handle async context fetching if needed.
  try {
    const { env } = getCloudflareContext();
    if (!env.DB) {
      throw new Error("Database binding 'DB' not found in Cloudflare context.");
    }
    return env as Env;
  } catch (error) {
    console.error("Failed to get Cloudflare context:", error);
    throw new Error(
      `Failed to get Cloudflare context: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

// Get all post items formatted for display
export async function getPostList(): Promise<PostItem[]> {
  try {
    const env = getEnv(); // Get env via context function
    const blogs = await getAllPosts(env, "blog");
    const projects = await getAllPosts(env, "project");
    const combined = [...blogs, ...projects];
    // formatPostsForDisplay already sorts by date descending via getAllPosts
    return formatPostsForDisplay(combined);
  } catch (error) {
    console.error("Error getting post list:", error);
    // Rethrow or return empty to allow frontend to show error
    throw error; // Or return [] and rely on console log
  }
}

// Get a single post item by ID, formatted for display
export async function getPostById(id: number): Promise<PostItem | null> {
  try {
    const env = getEnv(); // Get env via context function
    const db = getDB(env);
    const post = await db
      .select()
      .from(tables.posts)
      .where(eq(tables.posts.id, id))
      .get();

    if (!post) return null;

    // Format the single post using the same function
    const formatted = formatPostsForDisplay([post]);
    return formatted[0] ?? null;
  } catch (error) {
    console.error("Error getting post by ID:", error);
    throw error; // Or return null
  }
}

// Create a new post item
export async function createPost(
  postData: unknown // Accept unknown initially
): Promise<{
  success: boolean;
  error?: string;
  issues?: Record<string, string[] | undefined>; // Use specific type
}> {
  // 1. Validate input
  const validationResult = createPostInputSchema.safeParse(postData);
  if (!validationResult.success) {
    return {
      success: false,
      error: "Invalid input data.",
      issues: validationResult.error.flatten().fieldErrors,
    };
  }
  const validatedData = validationResult.data;
  const originalTitle = validatedData.title;

  // 2. Generate base slug if necessary
  let baseSlug = validatedData.slug;
  const slugIsValid = baseSlug && /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(baseSlug);
  if (!slugIsValid) {
    if (!originalTitle) {
      return {
        success: false,
        error: "Title is required to generate a slug.",
        issues: { title: ["Title is required."] },
      };
    }
    baseSlug = generateSlug(originalTitle);
    console.log(
      `Slug was invalid or missing. Generated base slug: ${baseSlug}`
    );
  }
  if (typeof baseSlug !== "string" || baseSlug.length === 0) {
    return {
      success: false,
      error: "Internal error: Could not determine a valid base slug.",
    };
  }

  // 3. ALWAYS append a unique suffix
  const uniqueSuffix = Date.now().toString(36).slice(-6); // 6-char timestamp-based suffix
  const finalSlug = `${baseSlug}-${uniqueSuffix}`;
  console.log(`Using final suffixed slug: ${finalSlug}`);

  // 4. Attempt to insert with the suffixed slug
  try {
    const env = getEnv();
    const newPostData: NewPost = {
      title: validatedData.title,
      slug: finalSlug, // Use the uniquely suffixed slug
      contentType: validatedData.contentType,
      content: validatedData.content,
      date: validatedData.date,
      description: validatedData.description ?? null,
      author: validatedData.author ?? null,
      tags: validatedData.tags?.join(",") ?? null,
      image: validatedData.image ?? null,
      featured: validatedData.featured ?? false,
      status: validatedData.status ?? "draft",
      publishDate: validatedData.publishDate ?? null,
    };

    const insertResult = await insertPost(env, newPostData);

    if (!insertResult || typeof insertResult.insertedId !== "number") {
      console.error("Failed to insert post or retrieve its ID.", insertResult);
      throw new Error("Failed to create post or retrieve ID during insert.");
    }
    const newPostId = insertResult.insertedId;

    // Now link images
    await updatePostImageLinks(
      env,
      newPostId,
      newPostData.image, // featured image URL
      newPostData.content // markdown content
    );

    // Success!
    revalidatePath("/content");
    revalidatePath("/posts");
    revalidatePath("/"); // Revalidate home page for featured projects
    revalidatePath(`/posts/${newPostData.contentType}`);
    revalidatePath(`/posts/${newPostData.contentType}/${newPostData.slug}`);
    return { success: true };
  } catch (error: unknown) {
    // Handle potential (though highly unlikely now) DB errors
    console.error(
      `Error creating post with suffixed slug '${finalSlug}':`,
      error
    );
    let errorMessage = "Unknown database error";
    if (error instanceof Error) {
      errorMessage = error.message;
    }

    // Check if it was still somehow a unique constraint error
    const isUniqueConstraintError = errorMessage.includes(
      "UNIQUE constraint failed"
    );
    if (isUniqueConstraintError) {
      errorMessage =
        "Failed due to a very unlikely slug collision. Please try again.";
    }

    return {
      success: false,
      error: `Failed to create post: ${errorMessage}`,
      // Maybe add a general issue or specific one if it was unique constraint
      issues: isUniqueConstraintError
        ? { slug: ["Failed due to slug collision."] }
        : undefined,
    };
  }
}

// Update an existing post item
export async function updatePost(
  id: number,
  postData: unknown // Accept unknown initially
): Promise<{
  success: boolean;
  error?: string;
  issues?: Record<string, string[] | undefined>; // Use specific type
}> {
  // Validate ID separately (basic check)
  if (typeof id !== "number" || id <= 0) {
    return { success: false, error: "Invalid post ID." };
  }

  // 1. Validate input data
  const validationResult = updatePostInputSchema.safeParse(postData);

  if (!validationResult.success) {
    return {
      success: false,
      error: "Invalid input data.",
      issues: validationResult.error.flatten().fieldErrors,
    };
  }

  // Use validated data (only fields that were present and valid)
  const validatedData = validationResult.data;

  // If no valid data was provided for update, maybe return early? Or let DB handle it.
  if (Object.keys(validatedData).length === 0) {
    return { success: false, error: "No valid fields provided for update." };
  }

  try {
    const env = getEnv(); // Get env via context function
    const db = getDB(env);

    // Fetch current post BEFORE we modify it so we can revalidate old paths *and* reuse its
    // content/image values to avoid extra round-trips later.
    const originalPost = await db
      .select({
        id: posts.id,
        content: posts.content,
        image: posts.image,
        slug: posts.slug,
        contentType: posts.contentType,
      })
      .from(posts)
      .where(eq(posts.id, id))
      .get();

    // 3. Map validated data to database update structure
    const { tags, ...restOfValidatedData } = validatedData;
    const postUpdateData: Partial<
      Omit<Post, "id" | "createdAt" | "updatedAt">
    > = { ...restOfValidatedData };
    if (tags) {
      postUpdateData.tags = tags.join(",");
    }
    // Ensure optional fields are set to null if explicitly provided as empty/null
    // (safeParse result 'validatedData' already respects schema optionality/nullability)
    // We just need to ensure the shape matches the DB expectations where needed.
    if (validatedData.description !== undefined)
      postUpdateData.description = validatedData.description ?? null;
    if (validatedData.author !== undefined)
      postUpdateData.author = validatedData.author ?? null;
    if (validatedData.image !== undefined)
      postUpdateData.image = validatedData.image ?? null;
    if (validatedData.publishDate !== undefined)
      postUpdateData.publishDate = validatedData.publishDate ?? null;
    // Note: boolean 'featured' and enum 'status' don't need null mapping

    // 4. Attempt to update database
    await updatePostRow(env, id, postUpdateData);

    // 5. Update image links only if content or image fields were modified
    const contentChanged = validatedData.content !== undefined;
    const imageChanged = validatedData.image !== undefined;

    if (contentChanged || imageChanged) {
      const mergedContent =
        validatedData.content ?? originalPost?.content ?? "";
      const mergedImage =
        validatedData.image ??
        (originalPost?.image as string | null | undefined);

      await updatePostImageLinks(env, id, mergedImage, mergedContent);
    } else {
      console.log(
        `No content/image changes for post ${id}, skipping image link update.`
      );
    }

    // Success!
    revalidatePath("/content");
    revalidatePath(`/publish/${id}`);
    revalidatePath("/"); // Revalidate home page for featured projects
    // Revalidate old path (based on data before update) if slug/type might have changed
    if (originalPost) {
      revalidatePath(`/posts/${originalPost.contentType}/${originalPost.slug}`);
    }

    // Revalidate new path based on potentially updated slug/type
    const currentPostData = await getPostById(id); // Get potentially updated data
    if (currentPostData) {
      revalidatePath(
        `/posts/${currentPostData.contentType}/${currentPostData.slug}`
      );
      revalidatePath(`/posts/${currentPostData.contentType}`);
    }
    revalidatePath("/posts");

    return { success: true };
  } catch (error: unknown) {
    // 6. Handle potential unique constraint violation on update
    let errorMessage = "Unknown error";
    if (error instanceof Error) {
      errorMessage = error.message; // Get message safely
    }

    const isUniqueConstraintError = errorMessage.includes(
      "UNIQUE constraint failed"
    );

    if (isUniqueConstraintError) {
      // Slug conflict on update, return specific validation error
      return {
        success: false,
        error: "Validation failed.",
        issues: {
          slug: ["This slug is already taken. Please choose another."],
        },
      };
    } else {
      // Other unexpected error
      console.error("Error updating post:", error);
      return {
        success: false,
        error: `Failed to update post: ${errorMessage}`,
      };
    }
  }
}

// Delete a post item
export async function deletePost(
  id: number
): Promise<{ success: boolean; error?: string }> {
  // Validate ID
  if (typeof id !== "number" || id <= 0) {
    return { success: false, error: "Invalid post ID." };
  }

  try {
    const env = getEnv(); // Get env via context function

    // Fetch post details before deleting for revalidation path
    const postToDelete = await getPostById(id);

    await deletePostRow(env, id);

    revalidatePath("/content");
    // Revalidate list paths first
    revalidatePath("/posts");
    revalidatePath("/"); // Revalidate home page for featured projects
    if (postToDelete) {
      revalidatePath(`/posts/${postToDelete.contentType}`);
      revalidatePath(`/posts/${postToDelete.contentType}/${postToDelete.slug}`);
    }

    return { success: true };
  } catch (error) {
    console.error("Error deleting post:", error);
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    return {
      success: false,
      error: `Failed to delete post: ${errorMessage}`,
    };
  }
}
